# ==javaScript==

## 01\_类型转换

- 转为字符串

  1. toString()

     - null 和 undefined 中没有 toString()

  2. String（）函数转为字符串
     - null 和 undefined 可以转换为字符串

```javascript
let a = 10;
// a = a.toString();
b = String(b);
```

- 数字转换

  - 使用 Number()函数来将其它类型转换为数值
  - parseInt() 将一个字符串转换为一个整数
  - parseFloat() 将一个字符串转换为浮点数

- 使用 Boolean()函数来将其它类型转换为布尔值

  1.  数字

      - 0 和 NaN 转换为 false 、其余是 ture

  2.  字符串
      - 空串 转换为 false 、其余是 ture 、null 和 undefinde 都转换为 false
  3.  对象：都会转换为 ture
  4.  0,NaN,空串，null，undefined，都为 false

  ```javascript
  let b = 1;
  console.log(Boolean(b));
  ```

- 转换为字符串
  - 显式转换： String()
  - 隐式转换：+ ""
- 转换为数字
  - 显式转换：Number()
  - 隐式转换：+
- 转换为布尔值

  - 显式转换： Boolean()
  - 隐式转换：!!

  ## 02\_运算符

  ### 算数运算符

- 运算符：可以用来对一个或多个操作数进行运算
  - 算数运算符：
    - +、 -、 \*、 /、 \*\*幂运算 %模运算，两个数相除取余数
  - 注意：
    - 算数运算时，除了字符串的加法
    - 其它运算的操作数是非数值时，都会转换为数值然后再运算
- js 是一门弱类型语言，当进行运算时会通过自动的类型转换来完成运算

- 当任意一个值和字符串做加法运算时，它会先将其它值转化为字符串
  然后再做拼串的操作
- 可以通过为任意类型+一个空串的形式来将其转换为字符串
  其原理和 String()函数相同，但使用起来更加简洁

```javascript
let a = 1;
a = a + "";
```

### 赋值运算符

- 赋值运算符用来将一个值赋值给一个变量
- ？？= 空赋值
- 只有当变量为 null 或 undefined 时才会对变量进行赋值

```javascript
a = null;
a ??= 12;
```

### 一元运算符

- +、 正号
  - 不会改变数值的符号
- -、 负号
  - 可以对数值进行符号位取反
- 当我们对非数值类型进行负数运算时，会先将其转换为数值然后再运算

### 自增和自减

- 自增运算符
  - ++ 使用后会使得原来的变量立刻增加 1
    - 自增分为前自增（++a） 和后自增（a++）
      - 无论是++a 还是 a++ 都会使原变量立刻增加 1，不同的是++a 和 a++ 所返回的值不同
        - a++ 是自增前的值
        - ++a 是自增后的值
- 自减运算符
  - -- 使用后会使得原来的变量立刻减 1
    - 自增分为前自减（--a） 和后自减（a--）
      - 无论是--a 还是 a-- 都会使原变量立刻减加 1, 不同的是--a 和 a-- 所返回的值不同
        - a-- 是自减前的值
        - --a 是自减后的值

### 逻辑运算符

- 逻辑非
  - ! 可以用来对一个值进行非运算,它可以对一个布尔值进行取反操作
  - ture---false、、、、false---ture
  - 如果对一个非布尔值进行取反，它会先将其转换为布尔值然后再取反， 可以利用这个特点将其他类型转换为布尔值
- && 逻辑与
  - 可以对两个值进行与运算
  - 当&&左右都为 ture 时，则返回 ture，否则返回 false
  - 与运算是短路的与，如果第一个值为 false，则不看第二个值
  - 与运算是找 false 的，如果找到 false 直接返回，没有 false 才返回 ture
  - 对于非布尔值进行与运算，它会转换为布尔值然后运算
  - 但是最终会返回原值
  - 如果第一个值为 false，则直接返回第一个值
  - 如果第一个值为 ture，则返回第二个值
- || 逻辑或
  - 可以对两个值进行与运算
  - 当||左右有 ture 时，则返回 ture，否则返回 false
  - 或运算是短路的或，如果第一个值为 ture，则不看第二个值
  - 或运算是找 ture 的，如果找到 ture 直接返回，没有 ture 才返回 false
  - 对于非布尔值进行与运算，它会转换为布尔值然后运算
  - 但是最终会返回原值
  - 如果第一个值为 ture，则直接返回第一个值
  - 如果第一个值为 false，则返回第二个值

### 关系运算符

- 关系运算符用来检查两个值之间的关系是否成立
  - 成立返回 ture，不成立返回 false
    - **>**；用来检查左值是否大于右值
    - **> =**;用来检查左值是否大于或等于右值
    - **<**；用来检查左值是否小于右值
    - **<=**；用来检查左值是否小于或等于右值
- 注意:
  - 当对非数值进行关系运算时，它会先将其转换为数值然后再比较
  - 当关系运算符的两端是两个字符串，它不会将字符串转换为数值，
  - 而是逐位的比较字符串的 Unicode 编码
  - 利用这个特点可以对字符串按照字母排序
  - 注意比较两个字符串格式的数字时一定要进行类型转换

### 相等运算符

- ==
  相等运算符，用来比较两个值是否相等
  使用相等运算符比较两个不同类型的值时，
  它会将其转换为相同的类型然后再比较
  类型转换后值相同也会返回 ture
  null 和 undefined 进行相等比较时会返回 ture
  NaN 不和任何值相等，包括它自身
- ===
  全等运算符，用来比较两个值是否全等
  它不会进行自动的类型转换，如果两个值的类型不同直接返回 false
  null 和 undefined 进行全等比较时会返回 ture
- !=
  不等，用来检查两个值是否不相等
  会自动类型转换
- !==
  不全等，用来检查两个值是否不相等
  不会自动类型转换

### 条件运算符

- 条件表达式 ? 表达式 1 ：表达式 2
- 条件运算符在执行时，会先对条件表达式进行求值判断

        如果结果为 true，则执行表达式 1
        如果结果为 false，则执行表达式 2

- **==运算符的优先级==**
  - ()拥有最高的优先级，可以直接通过（）来改变优先级即可

## 02\_流程控制

### 代码块

- 使用{}来创建代码块，代码块可以用来对代码进行分组，
- 同一个代码块中的代码，就是同一组代码，一个代码块中的代码要么都执行要么都不执行
- let 和 var
  - 在 js 中，使用 let 声明的变量具有块作用域
  - 在代码块中声明的变量无法在代码块的外部访问-
  - 使用 var 声明的变量，不具有块作用域

### if 语句

- 语法：

```bash
 if（条件表达式）{
     语句
 }
```

- 执行流程：

  - if 语句在执行前会先对 if 后的条件表达式进行求值判断，

        如果结果为true，则执行if后的语句
        如果为false则不执行

  - if 语句只会控制紧随其后的那一行代码，如果希望可以 - 制多行代码，可以使用{}将语句括起来
  - 最佳实践：即使 if 后只有一行代码，我们也应该编写代码块，这样结构会更加清晰
  - 如果 if 后的条件表达式不是布尔值，会转换为布尔值然 - 再运算

### if-else 语句

- 语法：

```bash
  if（条件表达式）{
      语句
  }else{
      语句
  }
```

- 执行流程：

  - if-else 执行时，先对条件表达式进行求值判断，

        如果结果为ture，则执行if后的语句
        如果结果为false，则执行else后的语句

- if-else if-else 语句：
  - 语法：
  ```bash
  if（条件表达式）{
      语句
  } else if（条件表达式）{
      语句
  } else if（条件表达式）{
      语句
  } else if（条件表达式）{
      语句
  } else if（条件表达式）{
      语句
  }  else{
      语句
  }
  ```
  - 执行流程：
    - if-else if-else 语句，会自上向下依次对 if 后的条件表达式进行求职判断，
    - 如果条件表达式结果为 true，则执行当前 if 后的语句，执行完毕语句结束
    - 如果条件表达式结果为 false 则继续向下判断，直到找到 true 为止
    - 如果所有的条件表达式都是 false，则执行 else 后的 1 语句 -
  - 注意:
    - if-else if-else 语句中只会有一个代码块被执行
    - 一旦有执行的代码块，下面的条件都不会再继续判断了
    - 所以一定要注意，条件编码的顺序

### switch 语句

- 语法

```bash
switch（表达式）{
    case 表达式：
         代码...
         break
    case 表达式：
         代码...
         break
     case 表达式：
         代码...
         break
     case 表达式：
         代码...
         break
    default：
        代码...
}
```

- 执行流程
  - switch 语句在执行时，会依次将 switch 后的表达式和 case 后的表达式进行全等比较
    - 如果比较结果为 ture，则自当前 case 处开始执行代码
    - 如果比较结果为 false，则继续比较其他 case 后的表达式，直到找到 ture 为止
    - 如果所有比较都是 false，则执行 default 后的语句
- 注意：
  - 当比较结果为 ture 时，会从当前 case 处开始执行代码
  - 也就是说 case 是代码执行的起始位置
  - 这就意味着只要是当前 case 后的代码，都会执行
  - 可以使用 break 来避免执行其他的 case

### while 循环

- 语法：

```bash
 let a = 1
 while（a < 100）{
        a++
     }
```

- 执行流程：
  - while 语句在执行时，会先对条件表达式进行判断
  - 如果结果为 true，则执行循环体，执行完毕，继续判断
  - 一直重复,直到条件表达式结果为 false，循环结束

### do-while 循环

- 语法：

```bash
let a = 10
 do{
     a--
       }while（a > 20）
```

- 执行顺序：

  - do-while 语句在执行时，会先执行 do 后的循环体,执行完毕后，会对 while 后的条件表达式进行判断
    - 如果为 false，循环终止
    - 如果为 true，继续循环

- 和 while 的区别:
  - while 语句是先判断再执行,do-while 语句实现执行再判断-
  - 实质的区别：do-while 语句可以确保至少循环一次

### for 循环

- 语法：

```bash
for（1.初始化表达式； 2.条件表达式； 4.更新表达式）{
                                3.语句.....
                            }
```

- 执行流程；

  1. 执行初始化表达式，初始化变量
  2. 执行条件表达式，判断循环是否执行
  3. 判断结果为 true，则执行循环体
  4. 执行更新表达式，对初始化变量进行修改
  5. 重复 2，直到判断为 false 为止

     - 初始化表达式，在循环的整个的生命周期只会执行一次
     - for 循环中的三个表达式的都可以省略
     - 使用 let 在 for 循环的（）中声明的变量是局部量，只能在 for 循环内部访问
     - 使用 var 在 for 循环的（）中声明的变量可以 for 循环的外部询问

### 循环嵌套

- 当循环发生嵌套时，外层循环每执行一次，内层循环就会执行一个完整的周期

### break 和 continue

- break
  - break 用来终止 switch 和循环语句
  - break 执行后，当前的 switch 或循环会立刻停止
  - break 会终止离他最近的循环
- continue
  - continue 用来跳过当前循环

## 03\_对象

### 对象介绍

- 数据类型：
  - 原始值
    1.  数字 Number
    2.  大整数 BigInt
    3.  字符串 String
    4.  布尔值 Boolean
    5.  空值 Null
    6.  未定义 Undefined
    7.  符号
  - 对象
    - 对象是 js 中的一种复合数据类型
    - 它相当于一个容器，在对象中可以储存各种不同类型数据
    - 原始值只能用来表示一些简单的数据，不能表示复杂数据
    - 创建对象 ， let obj = Obiect()
    - 对象中可以储存多个数据类型 ， 数据称为属性
    - 向对象中添加属性
      - 对象.属性名 = 属性值
    - 读取对象中的属性
      - 对象.属性名 ==**- 如果读取的是一个对象里没有的属性，不会报错而是 undefined**==
    - 删除属性
      - delete obj.name

### 对象的属性

- 属性名
  - 通常属性名就是一个字符串，所以属性名就可以是任何值，没有什么特殊要求
  - 但是如果你的属性名太特殊了，不能直接使用，需要使用[]来设置
  - 虽然如此，但是我们还是强烈建议属性名也按照标识符的规范命名
  - 也可以使用符号（symbol）作为属性名，来添加属性
  - 获取这种属性时，也需使用 symbol
  - 使用 symbol 添加的属性，通常是那些不希望被外界访问的属性
  - 使用[]去操作属性时，可以使用变量
- 属性值

  - 对象的属性值可以是任意的数据类型，也可以是一个对象
  - 使用 typeof 检查一个对象时，会返回 object

- in 运算符

  - 用来检查对象中是否含有某个属性
  - 语法 "属性名" in obj
  - 如果有返回 true， 没有返回 false

  ### 对象字面量

- 对象字面量
  - 可以直接使用{}来创建对象
  - 使用{}所创建的对象，可以直接向对象中添加属性
- 语法：

```bash
   {
      属性名：属性值，
      [属性名]：属性值，
         }
```

### 枚举属性

- 枚举属性，指将对象中的所有的属性全部获取
- for-in 语句
  - 语法：
    ```bash
    for(let propName in 对象){
               语句
           }
    ```
- for-in 的循环体会执行多次，有几个属性就会执行几次

  - 每次执行时，都会将一个属性名赋值给我们所定义的变量
  - 注意：并不是所有的属性都可以枚举，比如 使用符号添加的属性

  ```bash
    for(let a in obj){
            console.log(a, obj[a])
        }
  ```

### 可变类型

- 原始值都不属于可变类型，一旦创建就无法修改,在内存中不会创建重复的原始值
- 对象属于可变类型，
  - 对象创建完成后，可以任意添加删除修改对象中的属性
- 注意：
  - 当对两个对象进行相等或全等比较时，比较的是对象的内存地址
  - 如果有两个变量同时指向一个对象
    - 通过一个变量修改对象时，对另外一个变量也会产生影响
    - 当修改一个对象时，所有指向该对象的变量都会受到影响

### 改变量和改对像

- 修改对象
  - 修改对象时，如果有其他变量指向该对象，则所有指向改对像的变量都会受到影响
- 修改变量
  - 修改变量时，只会影响当前变量
- 在使用变量储存对象时，很容易因为改变变量指向的对象，提高代码的复杂度
  - 所以通常情况下，声明储存对象的变量时会使用 const
- 注意：
  - const 只是禁止变量被重新赋值，对对象的修改没有任何影响

### 对象的方法

- 方法（method）
  - 当一个对象的属性指向一个函数，
  - 那么我们就称这个函数是该对像的方法
  - 调用函数就称为调用对象的方法

## 04\_函数

### 函数

- 函数（function）
  - 函数也是一个对象
  - 它具有其他对象所有的功能
  - 函数可以储存代码，且可以在需要时调用这些代码
- 语法：

```bash
  function 函数名 (){
                 语句...
             }
```

- 调用函数：
  - 调用函数就是执行函数中的代码
  - 语法：
    - 函数对象()

### 函数的创建方式

函数的定义方式：

- 1.函数声明
  ```bash
     function 函数名(){
         语句...
    }
  ```
- 2.函数表达式

```bash
      const 变量 = function(){
           语句...
       }
```

- 3.箭头函数

```bash
   () => {
        语句...
    }
```

### 参数

- 形式参数
  - 在定义函数时，可以在函数中指定数量不等的形式参数（型参）
  - 在函数中定义型参，就相当于在函数内部声明了对应的变量但是没有赋值
- 实际参数
  - 在调用函数时，可以在函数的()传递数量不等的实参
  - 实参会赋值给其相对应的形参
- 参数：
  1. 如果实参和形参数量相同，则对应的实参赋值给对应的形参
  2. 如果实参多余形参，则多余实参不会被使用
  3. 如果形参多余实参，则多余的形参为 undefined
- 参数的类型：js 中不会检查参数的类型，可以传递任何值作为参数
- **==箭头函数的参数==**
  - 当箭头函数只有一个参数时，可以省略()
  - 定义参数时，可以为参数指定默认值，默认值，会在没有对应实参时生效
- **==对象作为参数==**
  - 对象可以作为参数传递
  - 传递实参时，传递的并不是变量本身，而是变量中储存的值
  - 函数每次调用，都会重新创建默认值
- **==函数作为参数==**
  - 在 js 中，函数也是一个对象（一等函数），别的对象能做的事情，函数也可以

### 函数的返回值

- 在函数中，可以通过 return 关键字来指定函数的返回值
  - 返回值就是函数的执行结果，函数调用完毕返回值便会作为结果返回
  - 任何值都可以作为返回值使用（包括对象和函数之类）
  - 如果 return 后不跟任何值，则相当于返回 undefined
  - 如果不写 return，那么函数的返回值依然是 undefined
  - return 一执行函数立即结束
- ==**箭头函数的返回值**==
  - 箭头函数的返回值可以直接写在箭头后面
  - 如果直接在箭头后设置对象字面量为返回值，对象字面量必须使用()括起来
  - > const fn = () => ({name:"刘长乐"})

### 作用域（scope）

- 作用域指的是一个变量的可见区域
- 作用域有两种：
  - 全局作用域
    - 全局作用域在网页运行时创建，在网页关闭时消失
    - 所有直接编写到 script 标签中的代码都位于全局作用域中
  - 局部作用域,块作用域
    - 块作用域是一种局部作用域
    - 块作用域在代码执行时创建，代码执行完他就销毁
    - 在块作用域中声明的变量是局部变量，只在块内部访问外部无法访问
- 函数作用域
  - 函数作用域也是一种局部作用域
  - 函数作用域在函数调用时产生，调用结束后销毁
  - 函数每次调用都会产生一个全新的函数作用域
  - 在函数中定义的变量是局部变量，只能在函数内部访问，外部无法访问

### Window 对象

- 在浏览器中，浏览器为我们提供了一个 window 对象，以直接访问
- window 对象代表的是浏览器窗口，通过该对像可以对览器窗口进行各种操作
- 除此之外 window 对象还负责储存 js 中的内置对象和浏览器的宿主对象
- window 对象的属性可以通过 window 对象访问，也可以直接访问
- 函数就可以认为是 window 对象的方法
- 向 window 对象中添加的属性会自动成为全局变量
- var 用来声明变量，作用和 let 相同，但是 var 不具有块作用域
- 在全局中使用 var 声明的变量，都会作为 window 对象的属性保存
- 使用 function 声明的函数，都会作为 window 的方法保存
- 使用 let 声明的变量不会储存在 window，而存在一个秘密的小地方
- var 虽然没有块作用域，但函数有作用域
- 在局部作用域中，如果没有使用 var 或 let 声明变量，则变量会自动成为 window 对象的属性，也就是全局变量

### 提升

- 变量的提升
  - 使用 var 声明变量，他会在所有代码执行前被声明，所以我们可以在函数声明前就访问变量
- 函数的提升
  - 使用函数声明创建的函数，会在其代码执行前被创建，所以我们可以在函数声明前调用函数
- let 声明的变量实际也会提升，但是在赋值之前解释器禁止对该变量的访问

### debugger

- debugger
  - 在代码中打了一个断点

### 立即执行函数

- 立即执行函数（iife）

  - 立即执行函数是一个匿名的函数，并且它只会调用一次
  - 可以来利用 iife 来创建一个一次性的函数作用域，避免变量冲突问题

    ```javascript
    (function () {
      let a = 1;
      console.log(a);
    })();
    ```

- 在开发中应该尽量减少直接在全局作用域编写代码!
- 所以我们的代码要尽量编写在局部作用域
- 如果使用 let 声明变量，可以使用{}来创建块作用域

### this

- 函数在执行时，js 解释器每次都会传递一个隐含的参数
- 这个参数就叫做 this,this 会指向一个对象
- this 所指向的对象会根据函数调用方式的不同而不同
  1. 以函数形式调用，this 指向的是 window
  2. 以方法的形式调用时，this 指向的是调用方法的对象
- 通过 this 可以在方法中引用调用方法的对象

### 箭头函数的 this

- 箭头函数
  - 例子
    - 无参箭头函数： () => 返回值
    - 一个参数： a => 返回值
    - 多个参数 (a, b) => 返回值
    - 只有一个语句的函数： () => 返回值
    - 只返回一个对象的函数： () => ({...})
    - 有多行语句的函数： () => { .... return 返回值 }
- 箭头函数没有自己的 this，他的 this 由外层作用域决定
- 箭头函数的 this 和他的调用方式无关

### 严格模式

- ==**"use strict"**==
- js 运行代码的模式有两种
  - 正常模式
    - 默认情况下代码都运行在正常模式中
    - 在正常模式下，语法检查并不严格
    - 他的原则是：能不报错的地方尽量不报错
    - 这种处理方式导致代码的运行性能较差
  - 严格模式
    - 在严格模式下，语法检查变得严格
      1.  禁止一些语法
      2.  更容易报错
      3.  提升了性能
- 在开发中尽量使用严格模式
  - 这样可以将一些隐藏的问题消灭在萌芽阶段。 同时也能提升代码的运行性能

## 05\_面向对象

### 面向对象

- 面向对象编程（opp）
  - 面向对象编程指，程序中的所有操作都是通过对象来完成， 做任何事情之前都需要先找到它的对象
    - 一个事物通常由两部分组成： 数据和功能
    - 一个对象由两部分组成： 属性和方法
    - 事物的数据到了对象中，体现为属性
    - 事物的功能到了对象中，体现为方法

### 类

- 使用 Object 创建对象的问题
  1.  无法区分不同类型的对象
  2.  不方便批量创建对象
- 在 js 中可以通过类（class）来解决这个问题
  1.  类是对像模板，可以将对象中的属性和方法直接定义在类中， 定义后，就可以直接通过类来创建对象
  2.  通过同一个类创建的对象，我们称为同类对象
      - 可以使用 instanceof 来检查一个对象是否是由某个类创建
      - 如果某个对象是由某个类所创建，则我们称该对象是这个类的实例

### 属性

```javascript
class Person {
  /*
                类的代码块，默认就是严格模式
                    类的代码是用来设置对象的属性的，不是什么代码都能写
            */
  name = "孙悟空"; //Person的实例属性 p1.name
  age = 18; //实例属性只能实例访问  p1.age
  static test = "test静态属性"; //使用static声明的属性，是静态属性（类属性）Person.test
  static jj = "静态属性"; //静态属性只能通过类去访问 Person.jj
}
```

### 方法

```javascript
class Person {
  name = "孙悟空";
  // 添加一种方法
  // sayHello = function(){

  // }
  sayHello() {
    console.log("大家好，我是" + this.name);
  }
}
```

### 构造函数

```javascript
class Person {
  // 在类中可以添加一个特殊的方法constructor
  // 该方法我们称为构造函数（构造方法）
  // 构造函数会在我们调用类创建对像时执行
  constructor(name, age, gander) {
    // console.log("构造函数执行了", name, age, gander)
    // 可以在构造函数中，为实例属性赋值
    // 在构造函数中，this表示当前所创建的对象
    this.name = name;
    this.age = age;
    this.gander = gander;
  }
  sayHello() {
    console.log(this.name);
  }
}
```

### 面向对象的特点：封装，继承和多态

1. 封装

- 对象就是一个用来储存不同属性的容器, 对象不仅储存属性，还要负责数据安全
- 直接添加到对象中的属性，并不安全，因为他们可以被任意修改
- 如何确保数据的安全：
  1.  私有化数据
      将需要保护的数据设置为私有，只能在内部使用
  2.  提供 setter 和 getter 方法来开放对数据的操作
- 属性设置私有的好处
  1.  可以控制属性的读写权限
  2.  可以在方法中对属性的值进行验证
- 封装主要用来保证数据的安全
  1.  属性私有化 开头加 #
  2.  通过 getter 和 setter 方法来操作属性
  ```bash
    get属性名(){
           return this.#属性
      }
     set属性名(参数) {
         this.#属性 = 参数
     }
  ```
  ```javascript
   class Person {
            #name
            #age
            #gander
            // #adrees = "花果山"       //使用#开头就变成了私有属性，私有属性只能在内部访问
            constructor(name, age, gander) {
                this.#name = name
                this.#age = age
                this.#gander = gander
            }
            getName() {
                return this.#name
            }
            setAge(age) {
                if (age >= 0) {
                    this.#age = age
                }
            }
  ```
- 多态：
  - 在 js 中不会检查参数类型，所以这就意味着任何数据都可以作为参数传递, 多态为我们提供了灵活性
- 继承
  - 可以通过 extends 关系来完成继承
  - 当一个类继承另一个类时，就相当于将另一个类中的代码复制到了当前类中
  - 继承发生时，被继承的类称为父类，继承的类为 子类
  - 通过继承可以减少重复的代码，并且可以在不修改一个类的前提对其进行扩展
  - 封装 ——————安全性
  - 继承 —————— 扩展性
  - 多态 ———————— 灵活性
  - 通过继承可以在不修改一个类的情况下对其进行扩展
  - ocp 开闭原则, 程序应该对修改关闭，对扩展开放

```javascript
class Dog extends Animal {
  //在子类中，可以通过创建同名方法来重写父类的方法
  sayHello() {
    console.log("汪汪汪");
  }
}

class Cat extends Animal {
  //重写构造函数
  constructor(name, age, gender) {
    //重写构造函数时，构造函数的第一行代码必须为super()
    super(name, age); //调用父类构造函数
    // this.name = name
    this.gender = gender;
  }
  sayHello() {
    super.sayHello(); //调用父类的sayHello
  }
}
```

### 对象的结构

- 对象中储存属性的区域实际有两个
  1.  对象自身
      - 直接通过对象所添加的属性，位于对象自身中
      - 在类中通过 x = y 的形式添加的属性，位于对象自身中
  2.  原型对象（prototype）
      - 对象中还有一些内容，会储存到其他的对象里（原型对象）
      - 在对象中会有一个属性用来储存原型对象，这个属性叫做 ** proto**
      - 原型对象也负责对象的储存属性，
        - 当我们访问对象中的属性时，会优先访问对象自身属性
        - 对象自身不保含属性时才会去原型对象中寻找
      - 会添加到原型对象中的情况
      1.  在类中通过 xxx(){}方式添加的方法，位于原型中
      2.  主动向原型中添加的属性或方法

### 原型对象

- 访问一个对象的原型对象

```bash
 对象.__proto__
 Object.getPrototypeOf(对象)
```

- 原型对象中的数据
  1.  对象中的数据（属性，方法等）
  2.  constructor （对象的构造函数）
- 注意：

  - 原型对象也有原型，这样就构成了一条原型链，根据对象的复杂程度不同，原型链的长度也不同
  - p 对象的原型链：p 对象 -- 原型 -- 原型 - null
  - obj 对象的原型链： obj 对象 -- 原型 -- null
  - 原型链：
    - 读取对象属性时，会优先对象自身属性
    - 如果对象中有，则使用，没有则与对象的原型中寻找
    - 如果原型中有，则使用，没有则去原型的原型中寻找
    - 直到找到 Object 对象的原型（Object 的原型没有原型（为 null））
    - 如果依然没找到，则返回 undefine
    - 作用域链，是找变量的链，找不到会报错
    - 原型链，是找属性的链，找不到会返回 undefined

- 所有同类型对象他们的原型对象都是同一个, 也就意味着，同类型对象的原型链是一样的
  - 原型的作用:
    - 原型就相当于一个公共区域，可以被所有该类实例访问
    - 可以将该类实例中所有的公共属性（方法）统一储存到原型中
    - 这样我们只需要创建一个属性，即可被所有实例访问
    - js 中继承就是通过原型来实现的， 当继承时，子类的原型就是父类的实例

### 修改原型

- 大部分情况下，我们是不需要修改原型对象
  - 注意：千万不要通过类的实例去修改原型
    1. 通过一个对象影响所有同类对象，这么做不合适
    2. 修改原型得先创建实例，麻烦
    3. 危险
  - 除了通过**proto**能访问对象原型外
  - 还可以通过类的 prototype 属性，来访问实例的原型
  - 修改原型时最好是通过类去修改
  - 好处：
    1. 修改是对所有对象原型进行修改
    2. 无需创建实例即可完成对原型的修改
  - 原则：
    1.  原型尽量不要手动修改
    2.  要改也不要通过实例对象去改
    3.  通过 类.prototype 属性去修改
    4.  最好不要直接给 prototype 去赋值

### instanceof 和 hansOwn

- instanceof 用来检查一个对象是否是一个类的实例
- instanceof 检查的是对象的原型链上是否有该类实例
- 只要原型链上有该实例，就会返回 true
- Object 是所有对象的原型，所以任何对象和 Object 进行 instanceof 运算都会返回 true
- 使用 in 运算符检查属性是时，无论属性在对象自身还是原型中，都会返回 true
- 对象.hasOwnProperty(属性名) （不推荐使用）,用来检查一个对象的自身是否含有某个属性
- Object.hasOwn(对象， 属性名),用来检查一个对象的自身是否含有某个属性

### new 运算符

- new 运算符是创建对象时要使用的运算符
- 使用 new 时，到底发生了哪些事情：
- 当使用 new 去调用一个函数时，这个函数会作为构造函数调用
- 使用 new 调用函数时，将会发生这些事：
  1.  创建一个普通的 js 对象（Object 对象 {}），为了方便，称其为新对象
  2.  将构造函数的 prototype 属性设置为新对象的原型
  3.  使用实参来执行构造函数，并且将新对象设置为函数中的 this
  4.  如果构造函数返回的是一个非原始值，则该值会作为 new 运算的返回值返回
- 如果构造函数的返回值是一个原始值或者没有指定返回值，则新的对象将会作为返回值返回

### 面向对象总结

- 面向对象本质就是，编写代码时所有的操作都是通过对象来进行的。
- 面向对象的编程：
  1.  找对象
  2.  搞对象
- 学习对象：

1. 明确这个对象代表什么，有什么用
2. 如何获取到这个对象
3. 如何使用这个对象（对象中的属性和方法）

- 对象的分类：

1. 内建对象 由 ES 标准定义的对象 比如 Object Fuction String ....
2. 宿主对象由浏览器提供的对象 BOM DOM
3. 自定义对象 由开发人员创建的对象

## 06\_数组

### 简介

- 数组 （Array）

```bash
  数组也是一种复合数据类型，在数组中可以储存多个不同类型的数据
    数组中储存的是有序的数据，数组中每个数据都有一个唯一的索引
        可以通过索引来操作获取数据
    数组中储存的数据叫做元素
    索引（index）是一组大于0的整数
    创建数组
        通过Array()来创建数组，也可以通过[]来创建数组
    向数组中添加元素
        语法：
            数组[索引] = 元素
    读取数组中的元素
        语法：
                数组[索引]
                如果读取了一个不存在的元素，不会报错而是返回undefined
    length
        获取数组的长度
        获取的实际就是数组的最大索引 + 1
        向数组最后添加元素：
            数组[数组.length] = 元素
            length是可以修改的
            数组.length = xxx

```

### 遍历数组

- 任何类型的值都可以成为数组中的元素
- 创建数组时尽量确保数组中储存的数据类型相同
- 遍历数组, 简单理解，就是获取到数组中的每一个元素

### for-of 语句

- for-of 语句可以用来遍历可迭代对象
- 语法：

  ```bash

                for(变量 of 可迭代对象){
                    语句...
                }
  ```

- 执行流程：
  - for-of 的循环体会执行多次，数组中有几个元素就会执行几次
  - 每次执行时都会将一个元素赋值给变量

### 数组的复制

- 如何去复制一个对象，复制对象要产生新的对象
- 当调用 slice 时，会产生一个新的数组对象，从而完成对数组的复制

- 浅拷贝（shallow copy）
  - 通常对对象的拷贝都是浅拷贝
  - 浅拷贝顾名思义，只对对象的浅层进行复制（只复制一层）
  - 如果对象中储存的数据是原始值，那么拷贝深浅就不重要
  - 浅拷贝只会对对象本身进行复制，不会复制对象中的属性（货元素）
- 深拷贝（deep copy）
  - 深拷贝不仅复制对象本身，还复制对象中的属性和元素
  - 因为性能问题，通常情况不太使用深拷贝
  ```
  const arr2 = structuredClone(arr)
  ```
- 展开运算符
  - 可以将一个数组中的元素展开到另一个数组中或者作为函数的参数传
  - 通过它也可以对数组进行浅复制
  ```
   const arr = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]
   const arr2 = [...arr]
  ```

### 对象的复制

- Object.assign(目标对象， 被复制的对象)==浅拷贝==
- 将被复制的对象中的属性复制到目标对象里，并将对象返回

### 高阶函数：

- 如果一个函数的参数或返回值是函数，则这个函数就称为高阶函数
- 将函数作为参数，意味着可以对另一个函数动态的传递代码

### 闭包：

- 闭包就是能访问到外部函数作用域中变量的函数
- 当我们需要隐藏一些不希望被别人访问的内容时就可以使用闭包
- 构成闭包的条件：
  1.  函数的嵌套
  2.  内部函数要引用外部函数中的变量
  3.  内部函数要作为返回值返回
- 闭包的生命周期：
  1. 闭包在外部函数调用时产生，外部函数每次调用都会产生一个全新的闭包
  2. 在内部函数调用时销毁（内部函数立即回收，闭包才会消失）
- 注意事项：
  - 闭包主要用来隐藏一些不希望被外部所访问的内容
  - 这就意味着闭包需要占用一定的内存空间
- 相较于类来说，闭包比较浪费内存空间（类可以使用原型而闭包不能）

### 递归

- 调用自身的函数称为递归函数， 递归的作用和循环基本一致
- 递归的核心思想就是将一个大的问题拆分为一个个小的问题，
- 编写递归函数，一定要包含两个条件：
  1. 基线条件 —————— 递归终止条件
  2. 递归条件 —————— 如何对问题进行拆分

### 可变字符串

- arguments
  - arguments 是函数中又一个隐含参数
  - arguments 是一个类数组对象
  - 和数组相似，可以通过索引来读取元素，也可以通过 for 循环变量，但是它不是一个数组对象，不能调用数组方法
  - arguments 用来储存函数的实参
  - 无论用户是否定义形参，实参都会储存到 arguments 对象中
  - 可以通过该对象直接访问实参
- 可变参数，在定义函数时可以将参数指定为可变参数
- 可变参数可以接收任意数量实参，并将它们统一储存到一个数组中返回
- 可变参数参数的作用基本和 arguments 一致。但是他们也有不同点
  1.  可变参数的名字可以自己指定
  2.  可变参数是一个数组，可以直接使用数组的方法
  3.  可变参数可以配合其它参数一起使用

```javascript
//当可变参数和普通参数一起用时，需要将可变参数写到最后
function fn2(a, b, ...args) {
  for (let a of arguments) {
    console.log(a);
  }
  console.log(args);
}
fn2(1, 2, 3, 4, 5, "hello");
```

### call 和 apply

- 根据函数的调用方式不同，this 的值也不同
  1.  以函数形式调用，this 是 window
  2.  以方法形式调用，this 是调用方法的对象
  3.  构造函数中，this 是新建对象
  4.  箭头函数没有自己的 this，由外层作用域决定
  5.  通过 call 和 apply 调用的函数，他们的第一个参数就是函数的 this
  6.  通过 bind 返回的函数，this 由 bind 第一个参数决定（无法修改）
- 调用函数除了通过 函数() 这种形式外，还可以通过或其他的方式来调用函数

  - 函数.call()
  - 函数.apply()
  - call 和 apply 除了可以调用函数，还可以用来指定函数中的 this
  - call 和 apply 的第一个参数，将会成为函数的 this
  - 通过 call 方法调用函数，函数的实参直接在第一个参数后一个一个列出来
  - 通过 apply 方法调用函数，函数的实参需要通过一个数组传递

  ```javascript
   let obj = {1, 2, 3}
   function fn2(a, b) {
            console.log("a =", a, "b =", b, this)
        }
        fn2.call(obj, 10, 20)
        // fn2.apply(obj, [123, 456])
  ```

- bind() 是函数的方法，可以用来创建一个新的函数
- bind 可以为新函数绑定 this,bind 可以为新函数绑定参数

```javascript
function fn(a, b, c) {
  console.log(this);
  console.log(a, b, c);
}
const obj = { name: "孙悟空" };
const newFn = fn.bind(obj, 1, 2, 3);
newFn();
```

- 箭头函数没有自身的 this，它的 this 由外层作用于决定
- 无法通过 call apply 和 bind 修改他的 this,箭头函数中没有 arguments

## 07\_内建对象

### 解构赋值

```javascript
const arr = ["孙悟空", "猪八戒", "沙和尚"];
let a, b, c;
[a, b, c] = arr; //解构赋值
let [d, e, f, g] = ["孙悟空", "猪八戒", "沙和尚", "唐僧"]; //声明同时解构
let [n1, n2, ...n3] = [1, 2, 3, 4, 5, 6]; //解构数组时，可以使用...设置获取获取多余元素
//可以通过解构赋值来交换两个变量的值
let a1 = 10;
let a2 = 20;
[a1, a2] = [a2, a1];
const arr2 = ["孙悟空", "猪八戒"];
[arr2[0], arr2[1]] = [arr2[1], arr2[0]];
// 数组中可以储存任意形式数据，也可以存数组
// 如果一个数组中的元素还是数组，则这个数组我们就称为二维数组
```

### 对象的解构

```javascript
const obj = { name: "孙悟空", age: 18, gander: "男" };
// let { name, age, gander } = obj      //声明同时解构对象
let name, age, gander;
({ name, age, gander } = obj);

let { address } = obj; //没有属性返回undefined
// console.log(name, age, gander, address);

let { name: a, age: b, gander: c, address: d = "花果山" } = obj;
console.log(a, b, c, d);
```

### 对象的序列化

- js 中的对象使用时都是存在于计算机的内存中的
- 序列化指将对象转换为一个可以储存的格式
- 在 js 中对象的序列化通常是将一个对象转换为字符串
- 序列化的用途：
  - 对象转换为字符串后，可以将字符串在不同语言之间进行传递
  - 甚至人可以直接对字符串进行读写操作，使得 js 对象可以在不同的语言之间传递
- 如何进行序列化：
  - 在 js 中有一个工具类 JSON js 对象表达法
  - js 对象序列化后会转换为一个字符串，这个字符串我们称其为 JSON 字符串
- 也可以手动编写 JSON 字符串，编写 JSON 的注意事项：

  1.  JSON 字符串有两种类型:JSON 对象 {}， JSON 数组 []
  2.  JSON 字符串的属性名必须使用双引号
  3.  JSON 中可以使用的属性值（元素）

      - 数字（Number）
      - 字符串（String） 必须使用双引号
      - 布尔值（Boolean）
      - 空值（Null）
      - 对象（Object）
      - 数组（Array [])

  4.  JSON 的格式和 js 对象的格式基本一致

- 注意：JSON 字符串如果属性是最后一个，则不要加逗号，

```javascript
const obj = {
  name: "孙悟空",
  age: 18,
};
//将obj转换为JSON字符串
const str = JSON.stringify(obj); //JSON.stringify() 可以将一个对象转换为JSON字符串

const obj2 = JSON.parse(str); //JSON.parse() 可以将 SON格式的字符串转换为js对象
```

### 深复制

```javascript
//对obj进行浅复制
const obj2 = Object.assign({}, obj);
//对obj进行深复制
const obj3 = structuredClone(obj);

//利用JSON来进行深复制
const str = JSON.stringify(obj);
const obj4 = JSON.parse(str);
const obj5 = JSON.parse(JSON.stringify(obj));
```

### Map

- Map 用来储存键值对结构数据（key-value）
- Object 中储存的数据就可以认为是一种键值对解构
- Map 和 Object 的主要区别
  - Object 中的属性名只能是字符串或符号，如果传递了一个其他类型的属性名
  - js 解释器会自动将其转换为字符串
- Map 中任何类型的值都可以称为数据的 key
- 创建 Map: new Map()
  - 属性和方法：
    - map.size() 获取 map 中键值对的数量
    - map.set(key, value) 向 map 中添加键值对
    - map.get(key) 根据 key 取值
    - map.delete(key) 删除指定数据
    - map.has(key) 检查 map 中是否包含指定键
    - map.clear() 删除全部键值对

```javascript
const map = new Map();
map.set("name", "孙悟空");
map.set("age", 18);
map.set("gander", "男");
console.log(map);
//将map转换为数组
// const arr = Array.from(map)
const arr = [...map];
console.log(arr);

//遍历map
for (const [key, value] of map) {
  console.log(key, value);
}

map.forEach((key, value) => {
  console.log(key, value);
});
// map.keys()  获取map中的所有key
// map.values() 获取map中的所有value
```

### Set

```javascript
// set用来创建一个集合
// 它的功能和数组类似，不同点在于set中不能储存重复的数据
// 使用方式：
//     创建
//         new Set()
//         new Set(数组)
//     方法
//         size 获取数量
//         add() 添加元素
//         has() 检查元素
//         delete() 删除元素
//创建一个Set
const set = new Set();
//向set中添加数据
set.add(10);
set.add("孙悟空");
```

### Math

- Math 一个工具类
- Math 中为我们提供了数学运算相关的一些常量和方法
- 常量： - Math.PI 圆周率
- 方法：
  - Math.abs() 求一个数的绝对值
  - Math.min() 求多个值中的最小值
  - Math.max() 求多个值中的最大值
  - Math.pow() 求 x 的 y 次方
  - Math.spat() 求一个数的平方根
  - Math.floor() 向下取整
  - Math.ceil() 向上取整
  - Math.round() 四舍五入取整
  - Math.trunc() 直接去除小数位
  - Math.radom() 返回一个 0 到 1 之间的随机数

### Date

- 在 js 中所有的和时间相关的数据都由 Date 对象表示
- 对象的方法：
  - getFullyear() 获取 4 位年份
  - getMonth() 返回当前月份（0~11）
  - getDate() 返回当前几日
  - getDay() 返回当前周几（0~6）0 表示周日
  - getTime() 返回当前日期的时间戳
    - 时间戳： 自 1970 年 1 月 1 日 0 时 0 分 0 秒到当前时间所经历的毫秒数， 计算机底层储存时间时，使用都是时间戳
  - Date.now() 获取当前时间戳

### 包装类：

- 在 js 中，除了直接创建原始值外，也可以创建原始值的对象
- 包装类： js 中一共有 5 个包装类
  - String
  - Number
  - Boolean
  - BigInt
  - Symbol
- 通过包装类可以将一个原始值包装为一个对象，
- 当我们对一个原始值调用方法或属性时，添加属性，js 解释器会临时将原始值包装为对应的对象
- 然后调用这个对象的属性或方法

### 正则表达式

- 正则表达式用来定义一个规则
- 通过这个规则计算机可以检查一个字符串是否符合规则
- 或者将字符串中符合规则的内容提取出来
- 正则表达式也时 js 中的一个对象

```javascript
//new RegExp() 可以接收两个参数（字符串）  1.正则表达式 2.匹配模式
let reg = new RegExp("abcd", "i");
//通过字面量来创建正则表达式：  正则表达式/匹配模式
reg = /a/i;

/*
            1.在正则表达式中大部分字符都可以直接写
            2.| 在正则表达式中表示或
            3.[] 表示或 （字符集）
                [a-z] 任意小写字母
                [A-Z] 任意大写字母
                [a-zA-Z] 任意的字母
                [0-9] 任意数字
            4.[^] 表示除了
                [^x] 除了x
            5. . 表示除了换行符外任意字符       \n \r
            6. 在正则表达式中使用\作为转义字符
            7.其它字符集
                \w      任意的单词字符 [a-zA-Z0-9]
                \W      除了单词字符   [^a-zA-Z0-9]
                \d      任意数字       [0-9]
                \D      除了数字       [^0-9]
                \s      空格
                \S      除了空格
                \b      单词边界
                \B      除了单词边界
        */
let re = /abc|def/;
re = /[a-z]/i; //匹配模式 i 表示忽略大小写

re = /[^a-z]/; //匹配只有小写字母以外内容的字符串

re = /^a/; //匹配开始位置的a

re = /a$/; //匹配结尾位置的a

re = /^a$/; //只匹配字母a，完全匹配，要求字符串必须和正则表达式一致
let result = re.test("A");
console.log(result);

/*
            量词
                {m} 正好m个
                [m,] 至少m个
                {m,n} m~n个
                + 一个以上 ，相当于 {1,}
                * 任意数量的a
                ？0~1次 {0,1}
        */

let re = /^a{3}$/;
re = /^(ab){1,}$/;
// re = /^[a-z]{3,4}$/
// re = /^ab+$/
// re = /^(ab)*/
re = /^(ab)?/;
let result = re.test("");

/*
        re.exec() 
            获取字符串中符合正则表达式的内容
    */
//g表示全局匹配
let str = "abcarcaxcaac";
let re = /a[a-z]c/gi;
let result = re.exec(str);
while (result) {
  console.log(result[0], result[1]);
  result = re.exec(str);
}
```

## 08_DOM

### 元素节点

```bash
元素节点对象（element）
    在网页中，每一个标签都是一个元素节点
    如何获取元素节点对象
        1.通过document对象，来获取元素节点
        2.通过document对象来创建元素节点
    通过document来获取已有的元素节点
    document.getElementById()
        根据id获取一个元素的节点
    document.getElementsByClassName()
        根据元素的class属性值获取一组元素节点对象
        返回的是一个类数组对象
        该方法返回的结果是一个实时更新的集合
    document.getElementsByTagName()
        根据标签名获取一组元素对象
        该方法返回的结果是一个实时更新的集合
        document.getElementsByTagName("*") 获取页面中所有的元素
    document.getElementsByName()
        根据name属性获取一组元素节点对象
        该方法返回的结果是一个实时更新的集合
        主要用于表单
    document.querySelectorAll()
        根据选择器去页面查询元素
        会返回一个类数组（不会实时更新）
    document.querySelector()
        根据选择器去页面查询第一个符合条件元素
    创建一个元素节点
        document.createElement()
            根据标签名创建一个元素节点对象

     通过元素节点对象获取其它节点的方法
     element.childNodes 获取当前元素的子节点（会包含空白的子节点）
     element.children 获取当前元素的子元素
     element.firstElementChild 获取当前元素的第一个子元素
     element.lastElementChild 获取当前元素的最后一个子元素
     element.nextElementSibling 获取当前元素的下一个兄弟元素
     element.previousElementSibling 获取当前元素的前一个兄弟元素
     element.parentNode 获取当前元素的父节点
     element.tagName  获取当前元素的标签名
```

### 文本节点

```bash
修改文本的三个属性
                element.textContent 获取或修改元素中的文本内容
                    获取的是标签中的内容，不会考虑css样式

                element.innerText 获取或修改元素中的文本内容
                    会考虑css样式
                    当字符串中有标签时，会自动对标签进行转义

                element.innerHTML 获取或修改元素中的html代码
                    可以直接向元素中添加html代码
                    innerHTML插入内容时，有被xss注入风险
```

### 属性节点

```bash
 属性节点*（Attr）
     方式一：
         读取： 元素.属性名      （注意class属性要使用className来读取)
             读取布尔值时，会返回true或false
         修改： 元素.属性名 = 属性值
     方法二：
         读取： 元素.getAttribute(属性名)
         修改： 元素.setAttribute(属性名， 属性值)
         删除： 元素.removeAttribute(属性名)
```

### 事件

```bash
事件（event）
    事件就是用户和页面之间发生的交互行为
        比如： 点击鼠标， 鼠标移动， 双击按钮，敲击键盘，松开按钮
    绑定响应函数的方式：
        1.可以直接在元素的属性中设置
        2.可以通过为元素的指定属性设置回调函数的形式来绑定事件（一个事件只能绑定一个响应函数）
        3.可以通过元素的 addEventListener() 方法
```

### 文档的加载

1. 将 script 标签写在 body 最后面
2. 将代码编写到 window.onload 的回调函数中
3. 将代码编写到 document 对象的 DOMContentloaded 的回调函数中
4. 将代码编写到外部 js 文件中，然后以 defer 的形式进行引入

### DOM 的修改

```bash
appendChild() 用于给一个节点添加子节点
insertAdjacentElement() 可以向 元素的任意位置添加元素
两个参数： 1.要添加的位置  2.要添加的元素
beforebegin 在元素前插入元素    afterend 在元素后插入元素
beforeend  标签的最后    afterbegin  标签的开始
replaceWith()  使用一个元素替换当前元素
remove()   用来删除当前元素

 //弹出一个友好提示
 let flag = confirm("确认要删除【" + empName + "】吗？")
```

### 节点的复制

- 使用 cloneNode() 方法对节点进行复制节点时，它会复制节点的所有特点包括各种属性
- 可以通过 true 作为参数。同时复制节点子元素

### 读取 css 样式

```bash
 getComputedStyle()
     它会返回一个对象，这个对象包含当前元素所
     参数
         1.要获取样式的对象
         2.要获取的伪元素
     返回值：
         返回一个对象，对象中储存了当前元素的
     注意：
         样式对象中返回的值，不一定能拿来计算
             所以使用时，一定要确保值可以计算

       元素.clientHeight
 元素.clientWidth
     获取元素内部高度和宽度（包括内容区和内边距）
 元素.offsetHeight
 元素.offsetWidth
     获取元素的可见框的大小，（包括内容区，内边距，边框）
 元素.offsetTop
 元素.offsetLeft
     获取元素相对于其定位父元素的偏移量
 元素.offsetParent
     获取元素的定位父元素
 元素.scrollHeight
 元素.scrollWidth
     获取元素滚动区域大小
 元素.scrollTop
 元素.scrollLeft
     获取或设置元素滚动条的偏移量

```

### 修改 css 样式

```bash
  可以通过修改class属性来间接的修改样式
  box1.className += " box2"
  元素.classList 是一个对象， 对象中提供了对当前元素的类的各种操作方法
  元素.classList.add()  向元素中添加一个或多个class
  元素.classList.remove()  移除元素中一个或多个class
  元素.classList.toggle()   切换元素中的class
  元素.classList.replace()   替换class
  元素.classList.contains()   检查class
```

### 事件对象

- 多种事件对象有一个共同点祖先 Event
  - event.target 触发事件的对象
  - event.currentTarget 绑定事件对象 （同 this）
  - event.stopPropagation() 停止事件传导
  - event.preventDefault() 取消默认行为

### BOM 对象

```bash
      浏览器对象模型
      BOM为我们提供了一组对象，
          Window    ——————   代表浏览器窗口
          Navigator   ——————   浏览器的对象    （可以用来识别浏览器）
          Location    ————————     浏览器地址栏信息
          History   ————————    浏览器的历史记录（控制浏览器前进后退）
          Screen   ——————————   屏幕信息
  BOM对象是作为window对象的属性保存的，所以可以直接在js中访问这些对象

  location   表示浏览器地址栏的信息
    可以直接将location的值修改为一个新地址
    location.assign()   跳转到一个新地址
    location.replace()   跳转到一个新地址，（无法通过回退按钮回退）
    location.reload(true)    刷新页面
    location.href      获取当前地址

     history.back()    回退按钮
     history.forward()   前进按钮
     history.go()     可以向前也可以向后
```
